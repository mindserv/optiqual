# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'optiqual_ui.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import os
import json
import subprocess
from datetime import datetime
from sqlalchemy.sql import text
from common.database import TestStatus, TestResults, Dut, DummyRxAccuracy, TestSweeps, Station, TestRxPowerSweep
from common.database import get_connection, get_session

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QDesktopWidget, QTextEdit, QVBoxLayout, QHBoxLayout, QComboBox
from PyQt5.QtCore import QThread, pyqtSignal
from PyQt5.QtGui import QPixmap

from ui_helpers import get_test_classes, construct_pytest_cli


OPT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DEFAULT_LOG_DIR = os.path.join(OPT_DIR, "test_logs")
UI_DIR = os.path.join(OPT_DIR, "ui")

DB_HOST = "localhost"  # or your database host
DB_PORT = 5432  # default PostgreSQL port
DB_USER = "postgres"
DB_PASSWORD = "postgres"


# TODO: Auto detect test table names
TEST_CLASS_TABLE_MAP = {"TestSweeps": TestSweeps, "TestResults": TestResults,
                        "Dut": Dut, "DummyRxAccuracy": DummyRxAccuracy, "Station": Station,
                        "TestRxPowerSweep": TestRxPowerSweep}

# Move the db session to common utilities

def _get_db_connection(database):
    db = get_connection(DB_USER, DB_PASSWORD, DB_HOST, DB_PORT, database)
    return db

class ScriptRunner(QThread):
    output_signal = pyqtSignal(str)
    results_signal = pyqtSignal(list)  # For test results

    def __init__(self, test_class, prod, station, sn, pn, result_file_path, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.test_class = test_class
        self.prod = prod
        self.station = station
        self.sn = sn
        self.pn = pn
        self.result_file_path = result_file_path

    def run(self):
        #script = 'your_script.py'  # Change this to your actual script path
        cmd = construct_pytest_cli(self.test_class, self.prod, self.station, self.sn,
                                   self.pn, self.result_file_path)
        print(cmd)
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # Line-buffered
            universal_newlines=True  # Text mode
        )

        results = []
        # Read stdout line by line
        while True:
            output = process.stdout.readline()  # Read line by line

            if output:
                self.output_signal.emit(output.strip())
            if process.poll() is not None:  # Break if process has terminated
                break

        # Capture any remaining errors
        stderr_output = process.stderr.read()
        if stderr_output:
            self.output_signal.emit(stderr_output.strip())

        self.results_signal.emit(results)

    def _parse_result(self, line):
        """
        Parse a line of output for test results.
        Expected format: "Test result: <TestName> - <Result>"
        """
        try:
            if ":" in line and "-" in line:
                parts = line.split(":")[1].strip().split(" - ")
                test_name = parts[0].strip()
                result = parts[1].strip()
                return {"test_name": test_name, "result": result}
        except IndexError:
            return None


class Ui_MainWindow(object):

    def __init__(self):
        self.is_highlighted = None
        self.blink_timer = None

    def load_tests(self):
        """Load tests and populate the list widget."""
        # Simulate loading a list of test names
        test_list = get_test_classes()
        # Clear the list widget before adding new items
        self.test_control_list_widget.clear()

        # Add each test to the list widget
        for test in test_list:
            self.test_control_list_widget.addItem(test)

    def auto_set_geometry(self, obj):
        screen = QDesktopWidget().screenGeometry()
        width = screen.width() * 0.8  # Set width to 80% of screen width
        height = screen.height() * 0.8  # Set height to 80% of screen height
        obj.setGeometry(round((screen.width() - width) // 2), round((screen.height() - height) // 2), round(width),
                        round(height))

    def populate_table(self, prod, test_name, test_result_id):
        query = f'select * from "{test_name}" where test_results_id = {test_result_id}'
        db_engine = _get_db_connection(prod)
        with db_engine.connect() as connection:
            result = connection.execute(text(query))
            rows = result.fetchall()
            columns = result.keys()

        # Set up table dimensions
        self.test_result_table_widget.setRowCount(len(rows))
        self.test_result_table_widget.setColumnCount(len(columns))
        self.test_result_table_widget.setHorizontalHeaderLabels(columns)

        # Populate table with data
        for row_idx, row in enumerate(rows):
            for col_idx, cell in enumerate(row):
                self.test_result_table_widget.setItem(
                    row_idx, col_idx, QtWidgets.QTableWidgetItem(str(cell))
                )
                # Resize columns and rows to fit contents
        self.test_result_table_widget.resizeColumnsToContents()
        self.test_result_table_widget.resizeRowsToContents()



    def on_result_row_clicked(self):
        """
        Handle the item click in the test result list widget.
        This will populate the test result table with random data.
        """
        prod, _, _, _ = self.get_selected_values()
        
        # get test_result_id from the json result file
        test_name = self.get_selected_values_from_results_list_widget()
        with open(self.result_file_path, 'r') as file:
            data = json.load(file)
        # TODO: Wrong assumption that always one data exists, may hit IndexError
        test_name_long_str = data['tests'][0]['nodeid']
        # TODO: fragile logic, improve
        test_result_id = 1
        if test_name in test_name_long_str:
            print("Retrieving test_result_id from the database...")
            test_result_id = data['tests'][0]['custom_data']['test_result_id']
            print(f"{test_name} selected and {test_result_id} found..")

        # Ensure scrollbars are visible
        self.test_result_table_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.test_result_table_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        # self.test_result_table_widget.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)

        self.populate_table(prod, test_name, test_result_id)

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        # auto adjust geometry
        #screen_geometry = QDesktopWidget().availableGeometry()

        #MainWindow.resize(screen_geometry.width(), screen_geometry.height())
        #MainWindow.resize(800, 600)
        self.auto_set_geometry(MainWindow)

        # Central widget
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.central_layout = QVBoxLayout(self.centralwidget)
        self.centralwidget.setObjectName("centralwidget")

        # Add the logo on the right-most side next to the Stop button
        self.logo_label = QtWidgets.QLabel(self.centralwidget)
        self.logo_label.setGeometry(QtCore.QRect(740, 10, 100, 81))  # Adjust size and position as needed
        self.logo_label.setAlignment(QtCore.Qt.AlignCenter)  # Center the image
        self.logo_label.setScaledContents(True)
        self.logo_label.setObjectName("logo_label")
        logo_file_name = "cloudphotonix-logo.jpg"
        logo_file_path = f"{UI_DIR}/{logo_file_name}"
        pixmap = QPixmap(logo_file_path)
        self.logo_label.setPixmap(pixmap.scaled(10000, 10000))

        # Stop Button

        self.pushbutton_main = QtWidgets.QPushButton(self.centralwidget)
        self.pushbutton_main.setGeometry(QtCore.QRect(600, 10, 131, 81))
        self.pushbutton_main.setObjectName("pushButtonMain")
        self.pushbutton_main.setText("Stop")  # Initial button text

        # Add action for the Stop button
        self.stop_action = QtWidgets.QAction("Stop Action", MainWindow)
        self.pushbutton_main.clicked.connect(self.on_stop_clicked)
        self.stop_action.triggered.connect(self.on_stop_clicked)  # Connect to stop function

        # Labels and Text Edits
        self.prod_label = QtWidgets.QLabel(self.centralwidget)
        self.prod_label.setGeometry(QtCore.QRect(20, 20, 60, 16))
        self.prod_label.setObjectName("prod_label")
        self.prod_label.setText("Product")

        self.pt_display_sn = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.pt_display_sn.setGeometry(QtCore.QRect(360, 10, 211, 31))
        self.pt_display_sn.setObjectName("pt_display_sn")

        self.station_label = QtWidgets.QLabel(self.centralwidget)
        self.station_label.setGeometry(QtCore.QRect(20, 60, 60, 16))
        self.station_label.setObjectName("station_label")
        self.station_label.setText("Station")

        self.sn_label = QtWidgets.QLabel(self.centralwidget)
        self.sn_label.setGeometry(QtCore.QRect(319, 20, 41, 20))
        self.sn_label.setObjectName("sn_label")
        self.sn_label.setText("SN")

        self.pn_label = QtWidgets.QLabel(self.centralwidget)
        self.pn_label.setGeometry(QtCore.QRect(320, 60, 31, 20))
        self.pn_label.setObjectName("pn_label")
        self.pn_label.setText("PN")

        # pl2_sn = display_sn
        # pl5 = display_prod
        # pl6 = display_station
        # pl4 = display_pn
        #
        self.pt_display_pn = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.pt_display_pn.setGeometry(QtCore.QRect(360, 50, 211, 31))
        self.pt_display_pn.setObjectName("pt_display_pn")

        self.pt_display_prod = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.pt_display_prod.setGeometry(QtCore.QRect(90, 10, 211, 31))
        self.pt_display_prod.setObjectName("pt_display_prod")

        self.pt_display_station = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.pt_display_station.setGeometry(QtCore.QRect(90, 50, 211, 31))
        self.pt_display_station.setObjectName("pt_display_station")

        # Tabs Widget
        self.MainTab = QtWidgets.QTabWidget(self.centralwidget)
        self.MainTab.setGeometry(QtCore.QRect(20, 100, 1141, 611))

        self.MainTab.setObjectName("MainTab")

        # TestControl Tab
        self.TestControl = QtWidgets.QWidget()

        self.TestControl.setObjectName("TestControl")

        self.test_control_pn_label = QtWidgets.QLabel(self.TestControl)
        self.test_control_pn_label.setGeometry(QtCore.QRect(310, 60, 31, 20))
        self.test_control_pn_label.setObjectName("test_control_pn_label")
        self.test_control_pn_label.setText("PN")

        self.test_control_sn_label = QtWidgets.QLabel(self.TestControl)
        self.test_control_sn_label.setGeometry(QtCore.QRect(309, 20, 41, 20))
        self.test_control_sn_label.setObjectName("test_control_sn_label")
        self.test_control_sn_label.setText("SN")

        self.test_control_prod_label = QtWidgets.QLabel(self.TestControl)
        self.test_control_prod_label.setGeometry(QtCore.QRect(10, 20, 60, 16))
        self.test_control_prod_label.setObjectName("test_control_prod_label")
        self.test_control_prod_label.setText("Product")

        self.test_control_station_label = QtWidgets.QLabel(self.TestControl)
        self.test_control_station_label.setGeometry(QtCore.QRect(10, 60, 60, 16))
        self.test_control_station_label.setObjectName("test_control_station_label")
        self.test_control_station_label.setText("Station")

        # pl3 = test_control_sn
        # pl9 = test_control_prod
        # pl7 = test_control_station
        # pl8 = test_control_pn
        self.test_control_sn = QtWidgets.QPlainTextEdit(self.TestControl)
        self.test_control_sn.setGeometry(QtCore.QRect(350, 10, 211, 31))
        self.test_control_sn.setObjectName("test_control_sn")

        # Inside the `setupUi` method
        self.test_control_station = QComboBox(self.TestControl)
        self.test_control_station.setGeometry(QtCore.QRect(80, 50, 211, 31))
        self.test_control_station.setObjectName("test_control_station")
        self.test_control_station.addItems(["optiqual1", "optiqual2"])  # Example items

        self.test_control_pn = QComboBox(self.TestControl)
        self.test_control_pn.setGeometry(QtCore.QRect(350, 50, 211, 31))
        self.test_control_pn.setObjectName("test_control_pn")
        self.test_control_pn.addItems(["MINDSERV-PN"])  # Example items

        self.test_control_prod = QComboBox(self.TestControl)
        self.test_control_prod.setGeometry(QtCore.QRect(80, 10, 211, 31))
        self.test_control_prod.setObjectName("test_control_prod")
        self.test_control_prod.addItems(["cpx100g", "10G_LR", "10G_SR"])  # Example items

        self.test_control_load_test_button = QtWidgets.QPushButton(self.TestControl)
        self.test_control_load_test_button.setGeometry(QtCore.QRect(580, 0, 101, 61))
        self.test_control_load_test_button.setObjectName("test_control_load_test_button")
        self.test_control_load_test_button.setText("Load Tests")
        self.test_control_load_test_button.clicked.connect(self.load_tests)

        self.test_control_run_test_button = QtWidgets.QPushButton(self.TestControl)
        self.test_control_run_test_button.setGeometry(QtCore.QRect(710, 0, 101, 61))
        self.test_control_run_test_button.setObjectName("test_control_run_test_button")
        self.test_control_run_test_button.setText("Run Tests")
        self.test_control_run_test_button.clicked.connect(self.run_test)


        self.test_control_list_widget = QtWidgets.QListWidget(self.TestControl)
        self.test_control_list_widget.setGeometry(QtCore.QRect(10, 90, 1100, 600))
        self.test_control_list_widget.setObjectName("test_control_list_widget")

        self.MainTab.addTab(self.TestControl, "Test Control")

        # TestResult Tab
        self.TestResult = QtWidgets.QWidget()
        self.TestResult.setObjectName("TestResult")
        self.test_result_list_widget = QtWidgets.QListWidget(self.TestResult)
        self.test_result_list_widget.setGeometry(QtCore.QRect(10, 20, 400, 600))
        self.test_result_list_widget.setObjectName("test_result_list_widget")

        # Get the results from database
        self.test_result_list_widget.itemClicked.connect(self.on_result_row_clicked)

        self.test_result_table_widget = QtWidgets.QTableWidget(self.TestResult)
        self.test_result_table_widget.setGeometry(QtCore.QRect(420, 20, 1100, 600))
        self.test_result_table_widget.setObjectName("test_result_table_widget")


        self.MainTab.addTab(self.TestResult, "Test Result")

        # TestLog Tab (empty tab)
        self.TestLog = QtWidgets.QWidget()
        self.TestLog.setObjectName("TestLog")
        self.MainTab.addTab(self.TestLog, "Test Log")

        self.log_output = QTextEdit(self.TestLog)
        self.log_output.setReadOnly(True)
        self.log_output.setGeometry(QtCore.QRect(10, 90, 1100, 600))
        #self.TestLog.addWidget(self.log_output)

        # Set central widget and status bar
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.MainTab.setCurrentIndex(2)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))

    def populate_results_in_gui(self, results):
        self.test_result_table_widget.setRowCount(len(results))
        self.test_result_table_widget.setColumnCount(2)  # Example: Test Name, Result

        for i, result in enumerate(results):
            test_name = result.get('name', 'Unknown Test')
            test_status = result.get('status', 'Unknown Status')

            self.test_result_table_widget.setItem(i, 0, QtWidgets.QTableWidgetItem(test_name))
            self.test_result_table_widget.setItem(i, 1, QtWidgets.QTableWidgetItem(test_status))

    def on_stop_clicked(self):
        """Handle the stop button click event."""
        print("Stop button clicked!")
        # Implement your logic to stop any running processes or operations here.
        self.pushbutton_main.setText("Stopped")  # Change button text to indicate it's stopped.

    def get_selected_values_from_results_list_widget(self):
        test_name = ""
        res = self.test_result_list_widget.selectedItems()[0].text() # Get selected product
        try:
            test_name = res.split(":")[0]
        except:
            print("Error - Test name not found")
        return test_name

    def get_selected_values(self):
        prod = self.test_control_prod.currentText()  # Get selected product
        sn = self.test_control_sn.toPlainText() # Get selected SN
        pn = self.test_control_pn.currentText()  # Get selected PN
        station = self.test_control_station.currentText()  # Get selected stage
        return prod, sn, pn, station

    def generate_filename_with_timestamp(self, base_name, extension):
        """
        Generate a filename with the current timestamp.

        Args:
            base_name (str): The base name for the file.
            extension (str): The file extension (e.g., 'json', 'txt').

        Returns:
            str: A filename in the format 'base_name_YYYYMMDD_HHMMSS.extension'.
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{base_name}_{timestamp}.{extension}"

    def toggle_button_color(self):
        """Toggle the button's background color to create a blinking effect."""
        if self.is_highlighted:
            # Reset to the default style
            self.test_control_run_test_button.setStyleSheet("")
        else:
            # Highlight the button (blinking state)
            self.test_control_run_test_button.setStyleSheet("background-color: yellow; color: black;")
        self.is_highlighted = not self.is_highlighted

    def start_blinking(self):
        """Start the blinking effect."""
        self.blink_timer.start(500)  # Blink every 500 milliseconds

    def stop_blinking(self):
        """Stop the blinking effect and reset the button color."""
        self.blink_timer.stop()
        self.test_control_run_test_button.setStyleSheet("")  # Reset to the default style
        self.is_highlighted = False

    def run_test(self):
        selected_items = self.test_control_list_widget.selectedItems()
        prod, sn, pn, station = self.get_selected_values()
        self.pt_display_pn.setPlainText(pn)
        self.pt_display_sn.setPlainText(sn)
        self.pt_display_station.setPlainText(station)
        self.pt_display_prod.setPlainText(prod)
        if not selected_items:
            print("No test selected!")
            return  # Exit if no test is selected

        selected_test = selected_items[0].text()  # Get the selected test text
        print(f"Running Test: {selected_test}")

        # Timer for blinking effect
        self.blink_timer = QtCore.QTimer()
        self.blink_timer.timeout.connect(self.toggle_button_color)
        self.is_highlighted = False  # Track the blinking state
        self.test_control_run_test_button.clicked.connect(self.start_blinking)
        self.log_output.clear()  # Clear previous logs
        self.test_control_run_test_button.setText("In Progress")  # Change button text
        self.test_control_run_test_button.setEnabled(False)  # Disable button during processing
        self.result_file_name =  self.generate_filename_with_timestamp("optiqual_report", "json")
        self.result_file_path = f"{DEFAULT_LOG_DIR}/{self.result_file_name}"
        self.thread = ScriptRunner(selected_test, prod, station, sn, pn, self.result_file_path)
        self.thread.output_signal.connect(self.update_log)  # Connect output signal
        self.thread.results_signal.connect(lambda: self.load_results_to_table(self.result_file_path))
        self.thread.finished.connect(self.on_test_complete)
        self.thread.start()  # Start the thread
        # Post results to the server

    def load_results_to_table(self, json_report_path):
        """
        Load test results from a Pytest JSON report file into the Test Results tab's list widget.
        """
        self.test_result_list_widget.clear()  # Clear existing entries

        try:
            # Read the JSON report file
            with open(json_report_path, 'r') as f:
                report_data = json.load(f)

            # Extract test cases and their outcomes
            tests = report_data.get('tests', [])
            if not tests:
                self.test_result_list_widget.addItem("No test results found in the report.")
                return

            for test in tests:
                test_name = test.get('nodeid', 'Unknown Test')  # Test identifier
                if 'Unknown Test' not in test_name:
                    test_name = test_name.split("::")[1]  # Get Test class

                test_outcome = test.get('outcome', 'Unknown Status')  # Test outcome (e.g., passed, failed, skipped)
                test_reason = test.get('call', {}).get('longrepr', 'No Details')  # Detailed failure reason if available

                # Format the display text
                display_text = f"{test_name}: {test_outcome}"
                list_item = QtWidgets.QListWidgetItem(display_text)
                if test_outcome == 'failed':
                    display_text += f" - {test_reason}"
                    list_item.setBackground(QtGui.QColor(255, 0, 0))
                else:
                    list_item.setBackground(QtGui.QColor(0, 255, 0))

                # Add formatted text as a list item
                self.test_result_list_widget.addItem(list_item)
        except Exception as e:
            self.test_result_list_widget.addItem(f"Error loading results: {str(e)}")

    def update_log(self, message):
        self.log_output.append(message)  # Append new output to log

    def on_test_selected(self):
        # Get the list of selected items
        selected_items = self.test_control_list_widget.selectedItems()
        if selected_items:  # Check if there's any selection
            # Assuming single selection; get the first item's text
            selected_test = selected_items[0].text()
            print(f"Selected Test: {selected_test}")
        else:
            print("No item selected.")

    def on_test_complete(self):
        self.test_control_run_test_button.setText("Run Tests")  # Reset button text
        self.stop_blinking()
        self.test_control_run_test_button.setEnabled(True)  # Re-enable the button


# Main function to run the application
def main():
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
